<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Evalis AI Interview</title>
<style>
  :root {
    --primary: #6C5CE7;
    --bg: #0a0a0f;
    --card: #12121a;
    --text: #e0e0e0;
    --accent: #00cec9;
    --danger: #ff4757;
    --success: #00b894;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100dvh;
    overflow-x: hidden;
    -webkit-text-size-adjust: 100%;
  }

  .container {
    max-width: 720px;
    margin: 0 auto;
    padding: 16px;
    padding-bottom: env(safe-area-inset-bottom, 16px);
  }

  /* --- AUTH SCREEN --- */
  .auth-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100dvh;
    gap: 20px;
    text-align: center;
  }

  .auth-screen h1 {
    font-size: 2rem;
    background: linear-gradient(135deg, var(--primary), var(--accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .auth-input {
    width: 100%;
    max-width: 320px;
    padding: 14px 18px;
    border-radius: 12px;
    border: 2px solid #2a2a3a;
    background: var(--card);
    color: var(--text);
    font-size: 16px; /* prevents iOS zoom */
    text-align: center;
    letter-spacing: 2px;
    outline: none;
    transition: border-color 0.3s;
  }

  .auth-input:focus { border-color: var(--primary); }

  /* --- INTERVIEW SCREEN --- */
  .interview-screen { display: none; }
  .interview-screen.active { display: block; }

  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid #1a1a2a;
    margin-bottom: 16px;
  }

  .timer {
    font-variant-numeric: tabular-nums;
    font-size: 1.1rem;
    color: var(--accent);
  }

  /* --- CHAT --- */
  .chat-container {
    height: calc(100dvh - 280px);
    overflow-y: auto;
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    padding: 8px 0;
  }

  .message {
    margin-bottom: 16px;
    padding: 14px 18px;
    border-radius: 16px;
    max-width: 88%;
    line-height: 1.55;
    font-size: 0.95rem;
    animation: fadeSlide 0.3s ease;
  }

  @keyframes fadeSlide {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .message.ai {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border: 1px solid #2a2a4a;
    border-bottom-left-radius: 4px;
    margin-right: auto;
  }

  .message.user {
    background: linear-gradient(135deg, #2d1b69, #1b3a4b);
    border: 1px solid #3a3a5a;
    border-bottom-right-radius: 4px;
    margin-left: auto;
  }

  .message.score {
    max-width: 100%;
    background: linear-gradient(135deg, #0a2a1a, #1a2a0a);
    border: 1px solid #2a4a3a;
    white-space: pre-wrap;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.85rem;
  }

  /* --- VOICE CONTROL AREA --- */
  .controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, var(--bg) 20%);
    padding: 20px 16px;
    padding-bottom: calc(env(safe-area-inset-bottom, 16px) + 16px);
  }

  .controls-inner {
    max-width: 720px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 12px;
    align-items: center;
  }

  /* Live transcript preview */
  .live-transcript {
    width: 100%;
    min-height: 40px;
    padding: 10px 16px;
    background: rgba(255,255,255,0.03);
    border: 1px solid #2a2a3a;
    border-radius: 12px;
    font-size: 0.9rem;
    color: #888;
    font-style: italic;
    text-align: center;
    transition: all 0.3s;
  }

  .live-transcript.has-text {
    color: var(--text);
    font-style: normal;
    border-color: var(--primary);
    background: rgba(108, 92, 231, 0.05);
  }

  .btn-row {
    display: flex;
    gap: 12px;
    width: 100%;
    justify-content: center;
  }

  .btn {
    padding: 14px 24px;
    border-radius: 14px;
    border: none;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }

  .btn:active { transform: scale(0.96); }

  .btn-primary {
    background: linear-gradient(135deg, var(--primary), #5a4bd1);
    color: white;
    flex: 1;
    justify-content: center;
  }

  .btn-send {
    background: linear-gradient(135deg, var(--accent), #00b3a8);
    color: #000;
    padding: 14px 20px;
  }

  .btn-danger {
    background: linear-gradient(135deg, var(--danger), #e04040);
    color: white;
    padding: 14px 20px;
  }

  .btn-score {
    background: linear-gradient(135deg, var(--success), #00a884);
    color: #000;
    flex: 1;
    justify-content: center;
  }

  .btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
  }

  /* --- MIC VISUALIZER --- */
  .mic-status {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.85rem;
    color: #666;
  }

  .mic-status.listening {
    color: var(--success);
  }

  .mic-status.listening .pulse-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--success);
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.4; transform: scale(1.5); }
  }

  .visualizer-bar {
    display: flex;
    gap: 2px;
    align-items: center;
    height: 20px;
  }

  .visualizer-bar .bar {
    width: 3px;
    background: var(--accent);
    border-radius: 2px;
    transition: height 0.1s;
    height: 4px;
  }

  /* --- FALLBACK TEXT INPUT --- */
  .fallback-input-row {
    display: none;
    width: 100%;
    gap: 8px;
  }

  .fallback-input-row.active {
    display: flex;
  }

  .fallback-input {
    flex: 1;
    padding: 14px 16px;
    border-radius: 12px;
    border: 2px solid #2a2a3a;
    background: var(--card);
    color: var(--text);
    font-size: 16px;
    outline: none;
  }

  .fallback-input:focus { border-color: var(--primary); }

  /* --- UPLOAD AREA --- */
  .upload-area {
    width: 100%;
    max-width: 400px;
    padding: 30px;
    border: 2px dashed #3a3a5a;
    border-radius: 16px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s;
  }

  .upload-area:hover, .upload-area.dragover {
    border-color: var(--primary);
    background: rgba(108, 92, 231, 0.05);
  }

  .upload-area.loaded {
    border-color: var(--success);
    border-style: solid;
  }

  /* --- TOAST --- */
  .toast {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-100px);
    background: var(--card);
    border: 1px solid #3a3a5a;
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 0.9rem;
    z-index: 1000;
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    pointer-events: none;
  }

  .toast.show { transform: translateX(-50%) translateY(0); }

  /* --- RESPONSIVE --- */
  @media (max-width: 480px) {
    .chat-container { height: calc(100dvh - 320px); }
    .message { max-width: 94%; font-size: 0.9rem; }
    .btn { padding: 12px 16px; font-size: 0.9rem; }
  }
</style>
</head>
<body>

<!-- TOAST -->
<div class="toast" id="toast"></div>

<!-- AUTH SCREEN -->
<div class="auth-screen" id="authScreen">
  <h1>‚ö° Evalis AI</h1>
  <p style="color:#888; max-width:300px;">Enterprise-grade AI Interview Platform</p>

  <input type="text" class="auth-input" id="accessCode"
         placeholder="Enter Access Code"
         autocomplete="off" autocorrect="off" spellcheck="false">

  <div class="upload-area" id="uploadArea" onclick="document.getElementById('cvFile').click()">
    <input type="file" id="cvFile" accept=".pdf,.txt,.doc,.docx" hidden>
    <p style="font-size:1.5rem;">üìÑ</p>
    <p style="margin-top:8px;">Upload Resume (PDF/TXT)</p>
    <p style="font-size:0.8rem; color:#666; margin-top:4px;" id="fileName">No file selected</p>
  </div>

  <button class="btn btn-primary" style="max-width:320px; width:100%;" onclick="startInterview()">
    üéôÔ∏è Start Interview
  </button>
</div>

<!-- INTERVIEW SCREEN -->
<div class="interview-screen" id="interviewScreen">
  <div class="container">
    <div class="header">
      <span style="font-weight:700; font-size:1.1rem;">‚ö° Evalis</span>
      <span class="timer" id="timer">00:00</span>
      <div class="mic-status" id="micStatus">
        <div class="pulse-dot"></div>
        <span id="micLabel">Initializing...</span>
      </div>
    </div>

    <div class="chat-container" id="chatContainer"></div>
  </div>

  <!-- CONTROLS -->
  <div class="controls">
    <div class="controls-inner">
      <!-- Live transcript preview -->
      <div class="live-transcript" id="liveTranscript">Listening...</div>

      <!-- Audio Visualizer -->
      <div class="visualizer-bar" id="visualizer">
        <!-- Bars injected by JS -->
      </div>

      <!-- Voice buttons -->
      <div class="btn-row" id="voiceBtnRow">
        <button class="btn btn-primary" id="btnListen" onclick="toggleListening()">
          üéôÔ∏è Listening...
        </button>
        <button class="btn btn-send" id="btnSend" onclick="sendCurrent()" disabled>
          Send ‚û§
        </button>
        <button class="btn btn-danger" id="btnEnd" onclick="endInterview()">
          ‚èπÔ∏è
        </button>
      </div>

      <!-- Fallback text input for unsupported browsers -->
      <div class="fallback-input-row" id="fallbackRow">
        <input type="text" class="fallback-input" id="fallbackInput"
               placeholder="Type your answer..." enterkeyhint="send">
        <button class="btn btn-send" onclick="sendFallback()">‚û§</button>
        <button class="btn btn-danger" onclick="endInterview()">‚èπÔ∏è</button>
      </div>

      <!-- Score button (shown after end) -->
      <div class="btn-row" id="scoreBtnRow" style="display:none;">
        <button class="btn btn-score" onclick="getScore()">üìä Get Interview Score</button>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================
// CONFIG
// ============================================
const WORKER_URL = "https://your-worker.your-subdomain.workers.dev"; // ‚Üê UPDATE THIS

// ============================================
// STATE
// ============================================
let accessCode = "";
let cvText = "";
let history = [];
let timerInterval = null;
let seconds = 0;
let isInterviewActive = false;

// ============================================
// CONTINUOUS LISTENING ENGINE
// ============================================
class ContinuousListeningEngine {
  constructor() {
    this.recognition = null;
    this.isListening = false;
    this.isPaused = false;
    this.isSupported = false;
    this.finalTranscript = "";
    this.interimTranscript = "";
    this.restartAttempts = 0;
    this.maxRestartAttempts = 50; // very resilient
    this.restartDelay = 100;
    this.silenceTimer = null;
    this.silenceThreshold = 1500; // ms of silence before allowing send
    this.lastSpeechTime = 0;
    this.audioContext = null;
    this.analyser = null;
    this.mediaStream = null;
    this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    this.isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    this.wakeLock = null;

    // Callbacks
    this.onInterim = null;
    this.onFinal = null;
    this.onStateChange = null;
    this.onVolumeChange = null;

    this._init();
  }

  _init() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      console.warn("Speech Recognition not supported");
      this.isSupported = false;
      return;
    }
    this.isSupported = true;
    this._createRecognition();
  }

  _createRecognition() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();

    recognition.continuous = !this.isIOS; // iOS doesn't support continuous well
    recognition.interimResults = true;
    recognition.maxAlternatives = 1;
    recognition.lang = "en-US";

    recognition.onstart = () => {
      this.isListening = true;
      this.restartAttempts = 0;
      this.restartDelay = 100;
      this._updateState("listening");
    };

    recognition.onresult = (event) => {
      this.interimTranscript = "";
      let newFinals = "";

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        if (event.results[i].isFinal) {
          newFinals += transcript + " ";
        } else {
          this.interimTranscript += transcript;
        }
      }

      if (newFinals) {
        this.finalTranscript += newFinals;
        this.lastSpeechTime = Date.now();
        this._resetSilenceTimer();
      }

      // Callbacks
      const display = this.finalTranscript + this.interimTranscript;
      if (this.interimTranscript && this.onInterim) {
        this.onInterim(display, false);
      }
      if (newFinals && this.onFinal) {
        this.onFinal(display, true);
      }
    };

    recognition.onerror = (event) => {
      console.warn("Recognition error:", event.error);

      // These errors are recoverable
      const recoverable = ["no-speech", "audio-capture", "network", "aborted"];

      if (recoverable.includes(event.error) && !this.isPaused && isInterviewActive) {
        this._scheduleRestart();
      } else if (event.error === "not-allowed") {
        this._updateState("denied");
        showToast("üéôÔ∏è Microphone access denied. Please allow mic access.");
      }
    };

    recognition.onend = () => {
      this.isListening = false;

      // Auto-restart if we should still be listening
      if (!this.isPaused && isInterviewActive) {
        this._scheduleRestart();
      } else {
        this._updateState("stopped");
      }
    };

    this.recognition = recognition;
  }

  _scheduleRestart() {
    if (this.restartAttempts >= this.maxRestartAttempts) {
      this._updateState("error");
      showToast("‚ö†Ô∏è Mic connection lost. Tap the mic button to retry.");
      return;
    }

    this.restartAttempts++;

    // Exponential backoff capped at 2s
    const delay = Math.min(this.restartDelay * Math.pow(1.3, this.restartAttempts - 1), 2000);

    setTimeout(() => {
      if (!this.isPaused && isInterviewActive) {
        this._safeStart();
      }
    }, delay);
  }

  _safeStart() {
    try {
      // Recreate recognition instance to avoid stale state (important on mobile)
      this._createRecognition();
      this.recognition.start();
    } catch (e) {
      console.warn("Start failed, retrying:", e.message);
      setTimeout(() => this._safeStart(), 500);
    }
  }

  _resetSilenceTimer() {
    clearTimeout(this.silenceTimer);
    this.silenceTimer = setTimeout(() => {
      // User has been silent ‚Äî auto-enable send button
      if (this.finalTranscript.trim().length > 0) {
        this._updateState("ready-to-send");
      }
    }, this.silenceThreshold);
  }

  _updateState(state) {
    if (this.onStateChange) this.onStateChange(state);
  }

  // --- PUBLIC API ---

  async start() {
    if (!this.isSupported) return false;

    this.isPaused = false;
    this.finalTranscript = "";
    this.interimTranscript = "";
    this.restartAttempts = 0;

    // Request mic permission proactively & get audio stream for visualizer
    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this._initVisualizer(this.mediaStream);
    } catch (e) {
      console.warn("Could not get media stream:", e);
      // Still try recognition ‚Äî it may work without getUserMedia on some browsers
    }

    // Acquire wake lock to prevent screen sleep on mobile
    await this._acquireWakeLock();

    this._safeStart();
    return true;
  }

  pause() {
    this.isPaused = true;
    clearTimeout(this.silenceTimer);
    try { this.recognition.stop(); } catch(e) {}
    this._updateState("paused");
  }

  resume() {
    if (!this.isSupported) return;
    this.isPaused = false;
    this.finalTranscript = "";
    this.interimTranscript = "";
    this._safeStart();
  }

  stop() {
    this.isPaused = true;
    clearTimeout(this.silenceTimer);
    try { this.recognition.stop(); } catch(e) {}
    this._destroyVisualizer();
    this._releaseWakeLock();
    this._updateState("stopped");
  }

  getCurrentTranscript() {
    return (this.finalTranscript + this.interimTranscript).trim();
  }

  clearTranscript() {
    this.finalTranscript = "";
    this.interimTranscript = "";
  }

  // --- AUDIO VISUALIZER ---

  _initVisualizer(stream) {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = 64;
      const source = this.audioContext.createMediaStreamSource(stream);
      source.connect(this.analyser);
      this._drawVisualizer();
    } catch(e) {
      console.warn("Visualizer init failed:", e);
    }
  }

  _drawVisualizer() {
    if (!this.analyser || this.isPaused) return;

    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteFrequencyData(dataArray);

    // Send volume data to UI
    if (this.onVolumeChange) {
      this.onVolumeChange(dataArray);
    }

    requestAnimationFrame(() => this._drawVisualizer());
  }

  _destroyVisualizer() {
    if (this.audioContext) {
      this.audioContext.close().catch(() => {});
      this.audioContext = null;
      this.analyser = null;
    }
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach(t => t.stop());
      this.mediaStream = null;
    }
  }

  // --- WAKE LOCK (prevent screen sleep during interview) ---

  async _acquireWakeLock() {
    if ('wakeLock' in navigator) {
      try {
        this.wakeLock = await navigator.wakeLock.request('screen');
        this.wakeLock.addEventListener('release', () => {
          // Re-acquire if page becomes visible again
          if (!this.isPaused && isInterviewActive) {
            this._acquireWakeLock();
          }
        });
      } catch(e) {
        console.warn("Wake lock failed:", e);
      }
    }
  }

  _releaseWakeLock() {
    if (this.wakeLock) {
      this.wakeLock.release().catch(() => {});
      this.wakeLock = null;
    }
  }
}

// ============================================
// GLOBAL ENGINE INSTANCE
// ============================================
const listeningEngine = new ContinuousListeningEngine();

// Wire up callbacks
listeningEngine.onInterim = (text, isFinal) => {
  updateLiveTranscript(text, false);
};

listeningEngine.onFinal = (text, isFinal) => {
  updateLiveTranscript(text, true);
  document.getElementById("btnSend").disabled = false;
};

listeningEngine.onStateChange = (state) => {
  const micStatus = document.getElementById("micStatus");
  const micLabel = document.getElementById("micLabel");
  const btnListen = document.getElementById("btnListen");

  switch(state) {
    case "listening":
      micStatus.className = "mic-status listening";
      micLabel.textContent = "Listening";
      btnListen.innerHTML = "üéôÔ∏è Listening...";
      btnListen.disabled = false;
      break;
    case "paused":
      micStatus.className = "mic-status";
      micLabel.textContent = "Paused";
      btnListen.innerHTML = "üéôÔ∏è Resume";
      break;
    case "ready-to-send":
      micStatus.className = "mic-status listening";
      micLabel.textContent = "Ready to send";
      // Auto-pulse the send button
      document.getElementById("btnSend").style.animation = "pulse 1s infinite";
      break;
    case "stopped":
      micStatus.className = "mic-status";
      micLabel.textContent = "Stopped";
      btnListen.innerHTML = "üéôÔ∏è Start Mic";
      break;
    case "denied":
      micStatus.className = "mic-status";
      micLabel.textContent = "Mic Denied";
      showFallbackInput();
      break;
    case "error":
      micStatus.className = "mic-status";
      micLabel.textContent = "Mic Error";
      btnListen.innerHTML = "üéôÔ∏è Retry";
      btnListen.disabled = false;
      break;
  }
};

listeningEngine.onVolumeChange = (dataArray) => {
  const bars = document.querySelectorAll("#visualizer .bar");
  if (!bars.length) return;

  // Map frequency data to bar heights
  const step = Math.floor(dataArray.length / bars.length);
  for (let i = 0; i < bars.length; i++) {
    const value = dataArray[i * step] || 0;
    const height = Math.max(4, (value / 255) * 28);
    bars[i].style.height = height + "px";
  }
};

// ============================================
// UI FUNCTIONS
// ============================================

function initVisualizer() {
  const viz = document.getElementById("visualizer");
  viz.innerHTML = "";
  for (let i = 0; i < 20; i++) {
    const bar = document.createElement("div");
    bar.className = "bar";
    viz.appendChild(bar);
  }
}

function updateLiveTranscript(text, hasFinal) {
  const el = document.getElementById("liveTranscript");
  if (text.trim()) {
    el.textContent = text;
    el.className = "live-transcript has-text";
  } else {
    el.textContent = "Listening...";
    el.className = "live-transcript";
  }
}

function showFallbackInput() {
  document.getElementById("voiceBtnRow").style.display = "none";
  document.getElementById("fallbackRow").className = "fallback-input-row active";
  document.getElementById("liveTranscript").textContent = "Voice not supported ‚Äî type below";
  document.getElementById("visualizer").style.display = "none";

  // Enter key to send
  document.getElementById("fallbackInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") sendFallback();
  });
}

function toggleListening() {
  if (listeningEngine.isListening) {
    listeningEngine.pause();
  } else {
    listeningEngine.resume();
  }
}

function addMessage(role, text) {
  const container = document.getElementById("chatContainer");
  const div = document.createElement("div");
  div.className = `message ${role}`;
  div.textContent = text;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}

function addScoreMessage(text) {
  const container = document.getElementById("chatContainer");
  const div = document.createElement("div");
  div.className = "message score";
  div.textContent = text;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}

// --- TTS (Text-to-Speech for AI responses) ---
function speak(text) {
  if (!('speechSynthesis' in window)) return;

  // Pause listening while AI speaks to prevent feedback
  const wasListening = listeningEngine.isListening;
  if (wasListening) listeningEngine.pause();

  // Cancel any ongoing speech
  speechSynthesis.cancel();

  const utterance = new SpeechSynthesisUtterance(text);
  utterance.rate = 1.05;
  utterance.pitch = 1.0;
  utterance.volume = 1.0;

  // Pick a good voice
  const voices = speechSynthesis.getVoices();
  const preferred = voices.find(v =>
    v.name.includes("Samantha") ||
    v.name.includes("Google US") ||
    v.name.includes("Microsoft Aria") ||
    (v.lang === "en-US" && v.localService)
  );
  if (preferred) utterance.voice = preferred;

  utterance.onend = () => {
    // Resume listening after AI finishes speaking
    if (wasListening || isInterviewActive) {
      setTimeout(() => listeningEngine.resume(), 300);
    }
  };

  utterance.onerror = () => {
    if (wasListening || isInterviewActive) {
      listeningEngine.resume();
    }
  };

  speechSynthesis.speak(utterance);
}

// Ensure voices are loaded
if ('speechSynthesis' in window) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
}

// --- TIMER ---
function startTimer() {
  seconds = 0;
  timerInterval = setInterval(() => {
    seconds++;
    const m = String(Math.floor(seconds / 60)).padStart(2, "0");
    const s = String(seconds % 60).padStart(2, "0");
    document.getElementById("timer").textContent = `${m}:${s}`;
  }, 1000);
}

function stopTimer() {
  clearInterval(timerInterval);
}

// --- TOAST ---
function showToast(msg) {
  const toast = document.getElementById("toast");
  toast.textContent = msg;
  toast.classList.add("show");
  setTimeout(() => toast.classList.remove("show"), 3000);
}

// ============================================
// CORE INTERVIEW LOGIC
// ============================================

// --- CV Upload ---
document.getElementById("cvFile").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById("fileName").textContent = file.name;
  document.getElementById("uploadArea").classList.add("loaded");

  if (file.type === "text/plain") {
    cvText = await file.text();
  } else if (file.type === "application/pdf") {
    // Basic PDF text extraction
    cvText = await extractPDFText(file);
  } else {
    cvText = `[Uploaded: ${file.name}]`;
  }

  showToast("‚úÖ Resume loaded!");
});

async function extractPDFText(file) {
  // Simple PDF text extraction without external library
  try {
    const buffer = await file.arrayBuffer();
    const text = new TextDecoder("utf-8").decode(buffer);
    // Extract readable strings from PDF
    const readable = text.match(/[\x20-\x7E]{4,}/g);
    return readable ? readable.join(" ").substring(0, 3000) : `[PDF: ${file.name}]`;
  } catch(e) {
    return `[PDF: ${file.name}]`;
  }
}

// Drag and drop
const uploadArea = document.getElementById("uploadArea");
uploadArea.addEventListener("dragover", (e) => {
  e.preventDefault();
  uploadArea.classList.add("dragover");
});
uploadArea.addEventListener("dragleave", () => uploadArea.classList.remove("dragover"));
uploadArea.addEventListener("drop", (e) => {
  e.preventDefault();
  uploadArea.classList.remove("dragover");
  const file = e.dataTransfer.files[0];
  if (file) {
    document.getElementById("cvFile").files = e.dataTransfer.files;
    document.getElementById("cvFile").dispatchEvent(new Event("change"));
  }
});

// --- API CALL ---
async function apiCall(mode, extra = {}) {
  const fd = new FormData();
  fd.append("mode", mode);
  fd.append("accessCode", accessCode);
  fd.append("cvText", cvText);
  fd.append("history", JSON.stringify(history));
  for (const [k, v] of Object.entries(extra)) {
    fd.append(k, v);
  }

  const res = await fetch(WORKER_URL, { method: "POST", body: fd });
  const data = await res.json();

  if (res.status === 403) {
    showToast(data.reply);
    throw new Error("Access denied");
  }

  return data;
}

// --- START INTERVIEW ---
async function startInterview() {
  accessCode = document.getElementById("accessCode").value.trim();
  if (!accessCode) {
    showToast("‚ö†Ô∏è Enter your access code");
    return;
  }

  showToast("üöÄ Starting interview...");

  try {
    const data = await apiCall("start");

    // Switch screens
    document.getElementById("authScreen").style.display = "none";
    document.getElementById("interviewScreen").classList.add("active");
    isInterviewActive = true;

    // Setup
    history = data.history || [];
    addMessage("ai", data.reply);
    speak(data.reply);
    startTimer();
    initVisualizer();

    // Start continuous listening
    if (listeningEngine.isSupported) {
      const started = await listeningEngine.start();
      if (!started) showFallbackInput();
    } else {
      showFallbackInput();
    }

  } catch(e) {
    console.error(e);
  }
}

// --- SEND CURRENT TRANSCRIPT ---
async function sendCurrent() {
  const text = listeningEngine.getCurrentTranscript();
  if (!text) {
    showToast("No speech detected. Say something first!");
    return;
  }

  // Disable send, pause mic
  document.getElementById("btnSend").disabled = true;
  document.getElementById("btnSend").style.animation = "";
  listeningEngine.pause();

  // Show user message
  addMessage("user", text);
  listeningEngine.clearTranscript();
  updateLiveTranscript("", false);

  try {
    const data = await apiCall("interview", { userMessage: text });
    history = data.history || history;
    addMessage("ai", data.reply);
    speak(data.reply); // This will auto-resume listening after TTS finishes
  } catch(e) {
    console.error(e);
    listeningEngine.resume();
  }
}

// --- SEND FALLBACK TEXT ---
function sendFallback() {
  const input = document.getElementById("fallbackInput");
  const text = input.value.trim();
  if (!text) return;

  input.value = "";
  addMessage("user", text);

  apiCall("interview", { userMessage: text }).then(data => {
    history = data.history || history;
    addMessage("ai", data.reply);
    speak(data.reply);
  }).catch(console.error);
}

// --- END INTERVIEW ---
function endInterview() {
  isInterviewActive = false;
  listeningEngine.stop();
  stopTimer();
  speechSynthesis.cancel();

  document.getElementById("voiceBtnRow").style.display = "none";
  document.getElementById("fallbackRow").className = "fallback-input-row";
  document.getElementById("liveTranscript").style.display = "none";
  document.getElementById("visualizer").style.display = "none";
  document.getElementById("scoreBtnRow").style.display = "flex";
  document.getElementById("micLabel").textContent = "Interview Ended";

  addMessage("ai", "Interview concluded. Click below to get your score.");
  showToast("‚èπÔ∏è Interview ended");
}

// --- GET SCORE ---
async function getScore() {
  addMessage("ai", "‚è≥ Analyzing your performance...");
  showToast("üìä Generating report...");

  try {
    const data = await apiCall("score");
    addScoreMessage(data.reply);
    document.getElementById("scoreBtnRow").style.display = "none";
  } catch(e) {
    console.error(e);
    addMessage("ai", "Failed to generate score. Please try again.");
  }
}

// ============================================
// VISIBILITY & LIFECYCLE HANDLERS
// ============================================

// Handle page visibility changes (critical for mobile!)
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible" && isInterviewActive && !listeningEngine.isPaused) {
    // Page came back into focus ‚Äî restart recognition
    console.log("Page visible again, restarting recognition");
    setTimeout(() => {
      if (!listeningEngine.isListening) {
        listeningEngine.resume();
      }
    }, 300);
  }
});

// Handle iOS audio context resume (required after user interaction)
document.addEventListener("touchstart", () => {
  if (listeningEngine.audioContext && listeningEngine.audioContext.state === "suspended") {
    listeningEngine.audioContext.resume();
  }
}, { once: true });

// Prevent accidental page close during interview
window.addEventListener("beforeunload", (e) => {
  if (isInterviewActive) {
    e.preventDefault();
    e.returnValue = "";
  }
});

// Handle Enter key on access code input
document.getElementById("accessCode").addEventListener("keydown", (e) => {
  if (e.key === "Enter") startInterview();
});
</script>

</body>
</html>
